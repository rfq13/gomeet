name: CD Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      
    strategy:
      matrix:
        service: [backend, frontend]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ matrix.service }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./packages/${{ matrix.service }}/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Create environment file for staging
      run: |
        cat > .env.staging << EOF
        APP_ENV=staging
        PORT=8080
        POSTGRES_DB=${{ secrets.POSTGRES_DB }}
        POSTGRES_USER=${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        LIVEKIT_API_KEY=${{ secrets.LIVEKIT_API_KEY }}
        LIVEKIT_API_SECRET=${{ secrets.LIVEKIT_API_SECRET }}
        CORS_ALLOWED_ORIGINS=${{ secrets.STAGING_CORS_ORIGINS }}
        PUBLIC_API_URL=${{ secrets.STAGING_API_URL }}
        PUBLIC_WS_URL=${{ secrets.STAGING_WS_URL }}
        PUBLIC_APP_NAME=${{ secrets.APP_NAME }}
        TURN_SERVER_URL=${{ secrets.TURN_SERVER_URL }}
        TURN_SERVER_USERNAME=${{ secrets.TURN_SERVER_USERNAME }}
        TURN_SERVER_CREDENTIAL=${{ secrets.TURN_SERVER_CREDENTIAL }}
        REGISTRY=${{ env.REGISTRY }}
        IMAGE_NAME=${{ env.IMAGE_NAME }}
        IMAGE_TAG=main-${{ github.sha }}
        EOF
        
    - name: Deploy to Staging Server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.DEPLOY_SERVER_HOST }}
        username: ${{ secrets.DEPLOY_SERVER_USER }}
        key: ${{ secrets.DEPLOY_SERVER_KEY }}
        script: |
          # Set deployment path
          DEPLOY_PATH=${{ secrets.DEPLOY_PATH }}
          
          # Create deployment directory if it doesn't exist
          mkdir -p $DEPLOY_PATH/staging
          cd $DEPLOY_PATH/staging
          
          # Download environment file
          echo '${{ secrets.DEPLOY_SERVER_KEY }}' > deploy_key
          chmod 600 deploy_key
          
          # Create docker-compose override for staging
          cat > docker-compose.override.yml << 'EOF'
          version: "3.8"
          services:
            backend:
              environment:
                - APP_ENV=staging
            frontend:
              environment:
                - PUBLIC_APP_NAME=GoMeet Staging
          EOF
          
          # Pull latest images
          docker-compose -f docker-compose.prod.yml -f docker-compose.override.yml pull
          
          # Stop existing services
          docker-compose -f docker-compose.prod.yml -f docker-compose.override.yml down || true
          
          # Start services
          docker-compose -f docker-compose.prod.yml -f docker-compose.override.yml up -d
          
          # Wait for services to be ready
          sleep 30
          
          # Clean up old images
          docker image prune -f
          
          # Remove deploy key
          rm -f deploy_key

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event.inputs.environment == 'production'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Create environment file for production
      run: |
        cat > .env.production << EOF
        APP_ENV=production
        PORT=8080
        POSTGRES_DB=${{ secrets.POSTGRES_DB_PROD }}
        POSTGRES_USER=${{ secrets.POSTGRES_USER_PROD }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD_PROD }}
        REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD_PROD }}
        JWT_SECRET=${{ secrets.JWT_SECRET_PROD }}
        LIVEKIT_API_KEY=${{ secrets.LIVEKIT_API_KEY_PROD }}
        LIVEKIT_API_SECRET=${{ secrets.LIVEKIT_API_SECRET_PROD }}
        CORS_ALLOWED_ORIGINS=${{ secrets.PRODUCTION_CORS_ORIGINS }}
        PUBLIC_API_URL=${{ secrets.PRODUCTION_API_URL }}
        PUBLIC_WS_URL=${{ secrets.PRODUCTION_WS_URL }}
        PUBLIC_APP_NAME=${{ secrets.APP_NAME }}
        TURN_SERVER_URL=${{ secrets.TURN_SERVER_URL_PROD }}
        TURN_SERVER_USERNAME=${{ secrets.TURN_SERVER_USERNAME_PROD }}
        TURN_SERVER_CREDENTIAL=${{ secrets.TURN_SERVER_CREDENTIAL_PROD }}
        REGISTRY=${{ env.REGISTRY }}
        IMAGE_NAME=${{ env.IMAGE_NAME }}
        IMAGE_TAG=main-${{ github.sha }}
        EOF
        
    - name: Deploy to Production Server
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.DEPLOY_SERVER_HOST_PROD }}
        username: ${{ secrets.DEPLOY_SERVER_USER_PROD }}
        key: ${{ secrets.DEPLOY_SERVER_KEY_PROD }}
        script: |
          # Set deployment path
          DEPLOY_PATH=${{ secrets.DEPLOY_PATH_PROD }}
          
          # Create deployment directory if it doesn't exist
          mkdir -p $DEPLOY_PATH/production
          cd $DEPLOY_PATH/production
          
          # Create backup before deployment
          docker-compose -f docker-compose.prod.yml down || true
          
          # Pull latest images
          docker-compose -f docker-compose.prod.yml pull
          
          # Start services
          docker-compose -f docker-compose.prod.yml up -d
          
          # Wait for services to be ready
          sleep 60
          
          # Clean up old images
          docker image prune -f

  health-check:
    name: Health Check After Deployment
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
    - name: Wait for health check
      run: |
        # Wait for services to be ready
        sleep 60
        
    - name: Check staging health
      if: needs.deploy-staging.result == 'success'
      run: |
        # Check backend health
        curl -f ${{ secrets.STAGING_API_URL }}/health || exit 1
        
        # Check frontend health
        curl -f ${{ secrets.STAGING_FRONTEND_URL }} || exit 1
        
    - name: Check production health
      if: needs.deploy-production.result == 'success'
      run: |
        # Check backend health
        curl -f ${{ secrets.PRODUCTION_API_URL }}/health || exit 1
        
        # Check frontend health
        curl -f ${{ secrets.PRODUCTION_FRONTEND_URL }} || exit 1

  notify-slack:
    name: Notify Slack
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging, deploy-production, health-check]
    if: always()
    
    steps:
    - name: Notify deployment success
      if: needs.health-check.result == 'success'
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: |
          ðŸš€ Deployment successful!
          
          **Repository:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          **Environment:** ${{ github.event.inputs.environment || 'staging' }}
          
          View changes: ${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        
    - name: Notify deployment failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        text: |
          âŒ Deployment failed!
          
          **Repository:** ${{ github.repository }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          **Environment:** ${{ github.event.inputs.environment || 'staging' }}
          
          Please check the workflow logs for details.
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}